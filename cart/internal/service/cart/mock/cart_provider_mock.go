// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/CatMacales/route256/cart/internal/service/cart.CartProvider -o cart_provider_mock.go -n CartProviderMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/CatMacales/route256/cart/internal/domain/model"
	"github.com/gojuno/minimock/v3"
)

// CartProviderMock implements mm_cart.CartProvider
type CartProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, u1 model.UserID, i1 model.Item) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, u1 model.UserID, i1 model.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartProviderMockAddItem

	funcDeleteCart          func(ctx context.Context, u1 model.UserID) (err error)
	funcDeleteCartOrigin    string
	inspectFuncDeleteCart   func(ctx context.Context, u1 model.UserID)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartProviderMockDeleteCart

	funcDeleteItem          func(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, u1 model.UserID, s1 model.Sku)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartProviderMockDeleteItem

	funcGetCart          func(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, u1 model.UserID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartProviderMockGetCart
}

// NewCartProviderMock returns a mock for mm_cart.CartProvider
func NewCartProviderMock(t minimock.Tester) *CartProviderMock {
	m := &CartProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartProviderMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartProviderMockAddItemParams{}

	m.DeleteCartMock = mCartProviderMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartProviderMockDeleteCartParams{}

	m.DeleteItemMock = mCartProviderMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartProviderMockDeleteItemParams{}

	m.GetCartMock = mCartProviderMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartProviderMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartProviderMockAddItem struct {
	optional           bool
	mock               *CartProviderMock
	defaultExpectation *CartProviderMockAddItemExpectation
	expectations       []*CartProviderMockAddItemExpectation

	callArgs []*CartProviderMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartProviderMockAddItemExpectation specifies expectation struct of the CartProvider.AddItem
type CartProviderMockAddItemExpectation struct {
	mock               *CartProviderMock
	params             *CartProviderMockAddItemParams
	paramPtrs          *CartProviderMockAddItemParamPtrs
	expectationOrigins CartProviderMockAddItemExpectationOrigins
	results            *CartProviderMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartProviderMockAddItemParams contains parameters of the CartProvider.AddItem
type CartProviderMockAddItemParams struct {
	ctx context.Context
	u1  model.UserID
	i1  model.Item
}

// CartProviderMockAddItemParamPtrs contains pointers to parameters of the CartProvider.AddItem
type CartProviderMockAddItemParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
	i1  *model.Item
}

// CartProviderMockAddItemResults contains results of the CartProvider.AddItem
type CartProviderMockAddItemResults struct {
	err error
}

// CartProviderMockAddItemOrigins contains origins of expectations of the CartProvider.AddItem
type CartProviderMockAddItemExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartProviderMockAddItem) Optional() *mCartProviderMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) Expect(ctx context.Context, u1 model.UserID, i1 model.Item) *mCartProviderMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartProviderMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartProviderMockAddItemParams{ctx, u1, i1}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) ExpectCtxParam1(ctx context.Context) *mCartProviderMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartProviderMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartProviderMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectU1Param2 sets up expected param u1 for CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) ExpectU1Param2(u1 model.UserID) *mCartProviderMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartProviderMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartProviderMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.u1 = &u1
	mmAddItem.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectI1Param3 sets up expected param i1 for CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) ExpectI1Param3(i1 model.Item) *mCartProviderMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartProviderMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartProviderMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.i1 = &i1
	mmAddItem.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) Inspect(f func(ctx context.Context, u1 model.UserID, i1 model.Item)) *mCartProviderMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartProviderMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartProvider.AddItem
func (mmAddItem *mCartProviderMockAddItem) Return(err error) *CartProviderMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartProviderMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartProviderMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartProvider.AddItem method
func (mmAddItem *mCartProviderMockAddItem) Set(f func(ctx context.Context, u1 model.UserID, i1 model.Item) (err error)) *CartProviderMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartProvider.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartProvider.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartProvider.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartProviderMockAddItem) When(ctx context.Context, u1 model.UserID, i1 model.Item) *CartProviderMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartProviderMock.AddItem mock is already set by Set")
	}

	expectation := &CartProviderMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartProviderMockAddItemParams{ctx, u1, i1},
		expectationOrigins: CartProviderMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartProvider.AddItem return parameters for the expectation previously defined by the When method
func (e *CartProviderMockAddItemExpectation) Then(err error) *CartProviderMock {
	e.results = &CartProviderMockAddItemResults{err}
	return e.mock
}

// Times sets number of times CartProvider.AddItem should be invoked
func (mmAddItem *mCartProviderMockAddItem) Times(n uint64) *mCartProviderMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartProviderMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartProviderMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_cart.CartProvider
func (mmAddItem *CartProviderMock) AddItem(ctx context.Context, u1 model.UserID, i1 model.Item) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, u1, i1)
	}

	mm_params := CartProviderMockAddItemParams{ctx, u1, i1}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartProviderMockAddItemParams{ctx, u1, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("CartProviderMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmAddItem.t.Errorf("CartProviderMock.AddItem got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmAddItem.t.Errorf("CartProviderMock.AddItem got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartProviderMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartProviderMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, u1, i1)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartProviderMock.AddItem. %v %v %v", ctx, u1, i1)
	return
}

// AddItemAfterCounter returns a count of finished CartProviderMock.AddItem invocations
func (mmAddItem *CartProviderMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartProviderMock.AddItem invocations
func (mmAddItem *CartProviderMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartProviderMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartProviderMockAddItem) Calls() []*CartProviderMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartProviderMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartProviderMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartProviderMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartProviderMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartProviderMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartProviderMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartProviderMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartProviderMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartProviderMockDeleteCart struct {
	optional           bool
	mock               *CartProviderMock
	defaultExpectation *CartProviderMockDeleteCartExpectation
	expectations       []*CartProviderMockDeleteCartExpectation

	callArgs []*CartProviderMockDeleteCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartProviderMockDeleteCartExpectation specifies expectation struct of the CartProvider.DeleteCart
type CartProviderMockDeleteCartExpectation struct {
	mock               *CartProviderMock
	params             *CartProviderMockDeleteCartParams
	paramPtrs          *CartProviderMockDeleteCartParamPtrs
	expectationOrigins CartProviderMockDeleteCartExpectationOrigins
	results            *CartProviderMockDeleteCartResults
	returnOrigin       string
	Counter            uint64
}

// CartProviderMockDeleteCartParams contains parameters of the CartProvider.DeleteCart
type CartProviderMockDeleteCartParams struct {
	ctx context.Context
	u1  model.UserID
}

// CartProviderMockDeleteCartParamPtrs contains pointers to parameters of the CartProvider.DeleteCart
type CartProviderMockDeleteCartParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
}

// CartProviderMockDeleteCartResults contains results of the CartProvider.DeleteCart
type CartProviderMockDeleteCartResults struct {
	err error
}

// CartProviderMockDeleteCartOrigins contains origins of expectations of the CartProvider.DeleteCart
type CartProviderMockDeleteCartExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCart *mCartProviderMockDeleteCart) Optional() *mCartProviderMockDeleteCart {
	mmDeleteCart.optional = true
	return mmDeleteCart
}

// Expect sets up expected params for CartProvider.DeleteCart
func (mmDeleteCart *mCartProviderMockDeleteCart) Expect(ctx context.Context, u1 model.UserID) *mCartProviderMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartProviderMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.paramPtrs != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by ExpectParams functions")
	}

	mmDeleteCart.defaultExpectation.params = &CartProviderMockDeleteCartParams{ctx, u1}
	mmDeleteCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// ExpectCtxParam1 sets up expected param ctx for CartProvider.DeleteCart
func (mmDeleteCart *mCartProviderMockDeleteCart) ExpectCtxParam1(ctx context.Context) *mCartProviderMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartProviderMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartProviderMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCart
}

// ExpectU1Param2 sets up expected param u1 for CartProvider.DeleteCart
func (mmDeleteCart *mCartProviderMockDeleteCart) ExpectU1Param2(u1 model.UserID) *mCartProviderMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartProviderMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartProviderMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteCart.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartProvider.DeleteCart
func (mmDeleteCart *mCartProviderMockDeleteCart) Inspect(f func(ctx context.Context, u1 model.UserID)) *mCartProviderMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartProviderMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartProvider.DeleteCart
func (mmDeleteCart *mCartProviderMockDeleteCart) Return(err error) *CartProviderMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartProviderMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartProviderMockDeleteCartResults{err}
	mmDeleteCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartProvider.DeleteCart method
func (mmDeleteCart *mCartProviderMockDeleteCart) Set(f func(ctx context.Context, u1 model.UserID) (err error)) *CartProviderMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartProvider.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartProvider.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	mmDeleteCart.mock.funcDeleteCartOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// When sets expectation for the CartProvider.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartProviderMockDeleteCart) When(ctx context.Context, u1 model.UserID) *CartProviderMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartProviderMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartProviderMockDeleteCartExpectation{
		mock:               mmDeleteCart.mock,
		params:             &CartProviderMockDeleteCartParams{ctx, u1},
		expectationOrigins: CartProviderMockDeleteCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartProvider.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartProviderMockDeleteCartExpectation) Then(err error) *CartProviderMock {
	e.results = &CartProviderMockDeleteCartResults{err}
	return e.mock
}

// Times sets number of times CartProvider.DeleteCart should be invoked
func (mmDeleteCart *mCartProviderMockDeleteCart) Times(n uint64) *mCartProviderMockDeleteCart {
	if n == 0 {
		mmDeleteCart.mock.t.Fatalf("Times of CartProviderMock.DeleteCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCart.expectedInvocations, n)
	mmDeleteCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCart
}

func (mmDeleteCart *mCartProviderMockDeleteCart) invocationsDone() bool {
	if len(mmDeleteCart.expectations) == 0 && mmDeleteCart.defaultExpectation == nil && mmDeleteCart.mock.funcDeleteCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCart.mock.afterDeleteCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCart implements mm_cart.CartProvider
func (mmDeleteCart *CartProviderMock) DeleteCart(ctx context.Context, u1 model.UserID) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	mmDeleteCart.t.Helper()

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, u1)
	}

	mm_params := CartProviderMockDeleteCartParams{ctx, u1}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, &mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCart.DeleteCartMock.defaultExpectation.paramPtrs

		mm_got := CartProviderMockDeleteCartParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCart.t.Errorf("CartProviderMock.DeleteCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteCart.t.Errorf("CartProviderMock.DeleteCart got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartProviderMock.DeleteCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartProviderMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, u1)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartProviderMock.DeleteCart. %v %v", ctx, u1)
	return
}

// DeleteCartAfterCounter returns a count of finished CartProviderMock.DeleteCart invocations
func (mmDeleteCart *CartProviderMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartProviderMock.DeleteCart invocations
func (mmDeleteCart *CartProviderMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartProviderMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartProviderMockDeleteCart) Calls() []*CartProviderMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartProviderMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartProviderMock) MinimockDeleteCartDone() bool {
	if m.DeleteCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartMock.invocationsDone()
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartProviderMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartProviderMock.DeleteCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartCounter := mm_atomic.LoadUint64(&m.afterDeleteCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && afterDeleteCartCounter < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartProviderMock.DeleteCart at\n%s", m.DeleteCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartProviderMock.DeleteCart at\n%s with params: %#v", m.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && afterDeleteCartCounter < 1 {
		m.t.Errorf("Expected call to CartProviderMock.DeleteCart at\n%s", m.funcDeleteCartOrigin)
	}

	if !m.DeleteCartMock.invocationsDone() && afterDeleteCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartProviderMock.DeleteCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartMock.expectedInvocations), m.DeleteCartMock.expectedInvocationsOrigin, afterDeleteCartCounter)
	}
}

type mCartProviderMockDeleteItem struct {
	optional           bool
	mock               *CartProviderMock
	defaultExpectation *CartProviderMockDeleteItemExpectation
	expectations       []*CartProviderMockDeleteItemExpectation

	callArgs []*CartProviderMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartProviderMockDeleteItemExpectation specifies expectation struct of the CartProvider.DeleteItem
type CartProviderMockDeleteItemExpectation struct {
	mock               *CartProviderMock
	params             *CartProviderMockDeleteItemParams
	paramPtrs          *CartProviderMockDeleteItemParamPtrs
	expectationOrigins CartProviderMockDeleteItemExpectationOrigins
	results            *CartProviderMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// CartProviderMockDeleteItemParams contains parameters of the CartProvider.DeleteItem
type CartProviderMockDeleteItemParams struct {
	ctx context.Context
	u1  model.UserID
	s1  model.Sku
}

// CartProviderMockDeleteItemParamPtrs contains pointers to parameters of the CartProvider.DeleteItem
type CartProviderMockDeleteItemParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
	s1  *model.Sku
}

// CartProviderMockDeleteItemResults contains results of the CartProvider.DeleteItem
type CartProviderMockDeleteItemResults struct {
	err error
}

// CartProviderMockDeleteItemOrigins contains origins of expectations of the CartProvider.DeleteItem
type CartProviderMockDeleteItemExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartProviderMockDeleteItem) Optional() *mCartProviderMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) Expect(ctx context.Context, u1 model.UserID, s1 model.Sku) *mCartProviderMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartProviderMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartProviderMockDeleteItemParams{ctx, u1, s1}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mCartProviderMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartProviderMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartProviderMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectU1Param2 sets up expected param u1 for CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) ExpectU1Param2(u1 model.UserID) *mCartProviderMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartProviderMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartProviderMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteItem.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectS1Param3 sets up expected param s1 for CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) ExpectS1Param3(s1 model.Sku) *mCartProviderMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartProviderMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartProviderMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteItem.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) Inspect(f func(ctx context.Context, u1 model.UserID, s1 model.Sku)) *mCartProviderMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartProviderMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartProvider.DeleteItem
func (mmDeleteItem *mCartProviderMockDeleteItem) Return(err error) *CartProviderMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartProviderMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartProviderMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartProvider.DeleteItem method
func (mmDeleteItem *mCartProviderMockDeleteItem) Set(f func(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error)) *CartProviderMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartProvider.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartProvider.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the CartProvider.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartProviderMockDeleteItem) When(ctx context.Context, u1 model.UserID, s1 model.Sku) *CartProviderMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartProviderMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartProviderMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &CartProviderMockDeleteItemParams{ctx, u1, s1},
		expectationOrigins: CartProviderMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartProvider.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartProviderMockDeleteItemExpectation) Then(err error) *CartProviderMock {
	e.results = &CartProviderMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times CartProvider.DeleteItem should be invoked
func (mmDeleteItem *mCartProviderMockDeleteItem) Times(n uint64) *mCartProviderMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartProviderMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mCartProviderMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_cart.CartProvider
func (mmDeleteItem *CartProviderMock) DeleteItem(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, u1, s1)
	}

	mm_params := CartProviderMockDeleteItemParams{ctx, u1, s1}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartProviderMockDeleteItemParams{ctx, u1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("CartProviderMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteItem.t.Errorf("CartProviderMock.DeleteItem got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteItem.t.Errorf("CartProviderMock.DeleteItem got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartProviderMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartProviderMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, u1, s1)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartProviderMock.DeleteItem. %v %v %v", ctx, u1, s1)
	return
}

// DeleteItemAfterCounter returns a count of finished CartProviderMock.DeleteItem invocations
func (mmDeleteItem *CartProviderMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartProviderMock.DeleteItem invocations
func (mmDeleteItem *CartProviderMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartProviderMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartProviderMockDeleteItem) Calls() []*CartProviderMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartProviderMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartProviderMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartProviderMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartProviderMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartProviderMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartProviderMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to CartProviderMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartProviderMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mCartProviderMockGetCart struct {
	optional           bool
	mock               *CartProviderMock
	defaultExpectation *CartProviderMockGetCartExpectation
	expectations       []*CartProviderMockGetCartExpectation

	callArgs []*CartProviderMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartProviderMockGetCartExpectation specifies expectation struct of the CartProvider.GetCart
type CartProviderMockGetCartExpectation struct {
	mock               *CartProviderMock
	params             *CartProviderMockGetCartParams
	paramPtrs          *CartProviderMockGetCartParamPtrs
	expectationOrigins CartProviderMockGetCartExpectationOrigins
	results            *CartProviderMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartProviderMockGetCartParams contains parameters of the CartProvider.GetCart
type CartProviderMockGetCartParams struct {
	ctx context.Context
	u1  model.UserID
}

// CartProviderMockGetCartParamPtrs contains pointers to parameters of the CartProvider.GetCart
type CartProviderMockGetCartParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
}

// CartProviderMockGetCartResults contains results of the CartProvider.GetCart
type CartProviderMockGetCartResults struct {
	ia1 []model.Item
	err error
}

// CartProviderMockGetCartOrigins contains origins of expectations of the CartProvider.GetCart
type CartProviderMockGetCartExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartProviderMockGetCart) Optional() *mCartProviderMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartProvider.GetCart
func (mmGetCart *mCartProviderMockGetCart) Expect(ctx context.Context, u1 model.UserID) *mCartProviderMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartProviderMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartProviderMockGetCartParams{ctx, u1}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartProvider.GetCart
func (mmGetCart *mCartProviderMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartProviderMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartProviderMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartProviderMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectU1Param2 sets up expected param u1 for CartProvider.GetCart
func (mmGetCart *mCartProviderMockGetCart) ExpectU1Param2(u1 model.UserID) *mCartProviderMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartProviderMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartProviderMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.u1 = &u1
	mmGetCart.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartProvider.GetCart
func (mmGetCart *mCartProviderMockGetCart) Inspect(f func(ctx context.Context, u1 model.UserID)) *mCartProviderMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartProviderMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartProvider.GetCart
func (mmGetCart *mCartProviderMockGetCart) Return(ia1 []model.Item, err error) *CartProviderMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartProviderMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartProviderMockGetCartResults{ia1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartProvider.GetCart method
func (mmGetCart *mCartProviderMockGetCart) Set(f func(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error)) *CartProviderMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartProvider.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartProvider.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartProvider.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartProviderMockGetCart) When(ctx context.Context, u1 model.UserID) *CartProviderMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartProviderMock.GetCart mock is already set by Set")
	}

	expectation := &CartProviderMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartProviderMockGetCartParams{ctx, u1},
		expectationOrigins: CartProviderMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartProvider.GetCart return parameters for the expectation previously defined by the When method
func (e *CartProviderMockGetCartExpectation) Then(ia1 []model.Item, err error) *CartProviderMock {
	e.results = &CartProviderMockGetCartResults{ia1, err}
	return e.mock
}

// Times sets number of times CartProvider.GetCart should be invoked
func (mmGetCart *mCartProviderMockGetCart) Times(n uint64) *mCartProviderMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartProviderMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartProviderMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_cart.CartProvider
func (mmGetCart *CartProviderMock) GetCart(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, u1)
	}

	mm_params := CartProviderMockGetCartParams{ctx, u1}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartProviderMockGetCartParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartProviderMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetCart.t.Errorf("CartProviderMock.GetCart got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartProviderMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartProviderMock.GetCart")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, u1)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartProviderMock.GetCart. %v %v", ctx, u1)
	return
}

// GetCartAfterCounter returns a count of finished CartProviderMock.GetCart invocations
func (mmGetCart *CartProviderMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartProviderMock.GetCart invocations
func (mmGetCart *CartProviderMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartProviderMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartProviderMockGetCart) Calls() []*CartProviderMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartProviderMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartProviderMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartProviderMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartProviderMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartProviderMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartProviderMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartProviderMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartProviderMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteCartInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetCartDone()
}
