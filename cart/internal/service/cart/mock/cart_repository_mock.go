// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/CatMacales/route256/cart/internal/service/cart.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/CatMacales/route256/cart/internal/domain/model"
	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_cart.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, u1 model.UserID, i1 model.Item) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, u1 model.UserID, i1 model.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartRepositoryMockAddItem

	funcDeleteCart          func(ctx context.Context, u1 model.UserID) (err error)
	funcDeleteCartOrigin    string
	inspectFuncDeleteCart   func(ctx context.Context, u1 model.UserID)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartRepositoryMockDeleteCart

	funcDeleteItem          func(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, u1 model.UserID, s1 model.Sku)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartRepositoryMockDeleteItem

	funcGetCart          func(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, u1 model.UserID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart
}

// NewCartRepositoryMock returns a mock for mm_cart.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartRepositoryMockAddItemParams{}

	m.DeleteCartMock = mCartRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartRepositoryMockDeleteCartParams{}

	m.DeleteItemMock = mCartRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartRepositoryMockDeleteItemParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddItemExpectation
	expectations       []*CartRepositoryMockAddItemExpectation

	callArgs []*CartRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddItemExpectation specifies expectation struct of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddItemParams
	paramPtrs          *CartRepositoryMockAddItemParamPtrs
	expectationOrigins CartRepositoryMockAddItemExpectationOrigins
	results            *CartRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddItemParams contains parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParams struct {
	ctx context.Context
	u1  model.UserID
	i1  model.Item
}

// CartRepositoryMockAddItemParamPtrs contains pointers to parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
	i1  *model.Item
}

// CartRepositoryMockAddItemResults contains results of the CartRepository.AddItem
type CartRepositoryMockAddItemResults struct {
	err error
}

// CartRepositoryMockAddItemOrigins contains origins of expectations of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartRepositoryMockAddItem) Optional() *mCartRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Expect(ctx context.Context, u1 model.UserID, i1 model.Item) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartRepositoryMockAddItemParams{ctx, u1, i1}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectU1Param2 sets up expected param u1 for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectU1Param2(u1 model.UserID) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.u1 = &u1
	mmAddItem.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectI1Param3 sets up expected param i1 for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectI1Param3(i1 model.Item) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.i1 = &i1
	mmAddItem.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Inspect(f func(ctx context.Context, u1 model.UserID, i1 model.Item)) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Return(err error) *CartRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartRepositoryMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartRepository.AddItem method
func (mmAddItem *mCartRepositoryMockAddItem) Set(f func(ctx context.Context, u1 model.UserID, i1 model.Item) (err error)) *CartRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartRepositoryMockAddItem) When(ctx context.Context, u1 model.UserID, i1 model.Item) *CartRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartRepositoryMockAddItemParams{ctx, u1, i1},
		expectationOrigins: CartRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.AddItem should be invoked
func (mmAddItem *mCartRepositoryMockAddItem) Times(n uint64) *mCartRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_cart.CartRepository
func (mmAddItem *CartRepositoryMock) AddItem(ctx context.Context, u1 model.UserID, i1 model.Item) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, u1, i1)
	}

	mm_params := CartRepositoryMockAddItemParams{ctx, u1, i1}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddItemParams{ctx, u1, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartRepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, u1, i1)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartRepositoryMock.AddItem. %v %v %v", ctx, u1, i1)
	return
}

// AddItemAfterCounter returns a count of finished CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartRepositoryMockAddItem) Calls() []*CartRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartRepositoryMockDeleteCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteCartExpectation
	expectations       []*CartRepositoryMockDeleteCartExpectation

	callArgs []*CartRepositoryMockDeleteCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteCartExpectation specifies expectation struct of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteCartParams
	paramPtrs          *CartRepositoryMockDeleteCartParamPtrs
	expectationOrigins CartRepositoryMockDeleteCartExpectationOrigins
	results            *CartRepositoryMockDeleteCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteCartParams contains parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParams struct {
	ctx context.Context
	u1  model.UserID
}

// CartRepositoryMockDeleteCartParamPtrs contains pointers to parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
}

// CartRepositoryMockDeleteCartResults contains results of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartResults struct {
	err error
}

// CartRepositoryMockDeleteCartOrigins contains origins of expectations of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Optional() *mCartRepositoryMockDeleteCart {
	mmDeleteCart.optional = true
	return mmDeleteCart
}

// Expect sets up expected params for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Expect(ctx context.Context, u1 model.UserID) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.paramPtrs != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by ExpectParams functions")
	}

	mmDeleteCart.defaultExpectation.params = &CartRepositoryMockDeleteCartParams{ctx, u1}
	mmDeleteCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCart
}

// ExpectU1Param2 sets up expected param u1 for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) ExpectU1Param2(u1 model.UserID) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteCart.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, u1 model.UserID)) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Return(err error) *CartRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartRepositoryMockDeleteCartResults{err}
	mmDeleteCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteCart method
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Set(f func(ctx context.Context, u1 model.UserID) (err error)) *CartRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	mmDeleteCart.mock.funcDeleteCartOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// When sets expectation for the CartRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartRepositoryMockDeleteCart) When(ctx context.Context, u1 model.UserID) *CartRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteCartExpectation{
		mock:               mmDeleteCart.mock,
		params:             &CartRepositoryMockDeleteCartParams{ctx, u1},
		expectationOrigins: CartRepositoryMockDeleteCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteCart should be invoked
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Times(n uint64) *mCartRepositoryMockDeleteCart {
	if n == 0 {
		mmDeleteCart.mock.t.Fatalf("Times of CartRepositoryMock.DeleteCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCart.expectedInvocations, n)
	mmDeleteCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCart
}

func (mmDeleteCart *mCartRepositoryMockDeleteCart) invocationsDone() bool {
	if len(mmDeleteCart.expectations) == 0 && mmDeleteCart.defaultExpectation == nil && mmDeleteCart.mock.funcDeleteCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCart.mock.afterDeleteCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCart implements mm_cart.CartRepository
func (mmDeleteCart *CartRepositoryMock) DeleteCart(ctx context.Context, u1 model.UserID) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	mmDeleteCart.t.Helper()

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, u1)
	}

	mm_params := CartRepositoryMockDeleteCartParams{ctx, u1}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, &mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCart.DeleteCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteCartParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, u1)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteCart. %v %v", ctx, u1)
	return
}

// DeleteCartAfterCounter returns a count of finished CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Calls() []*CartRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteCartDone() bool {
	if m.DeleteCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartMock.invocationsDone()
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartCounter := mm_atomic.LoadUint64(&m.afterDeleteCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && afterDeleteCartCounter < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.DeleteCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s with params: %#v", m.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && afterDeleteCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart at\n%s", m.funcDeleteCartOrigin)
	}

	if !m.DeleteCartMock.invocationsDone() && afterDeleteCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartMock.expectedInvocations), m.DeleteCartMock.expectedInvocationsOrigin, afterDeleteCartCounter)
	}
}

type mCartRepositoryMockDeleteItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemExpectation
	expectations       []*CartRepositoryMockDeleteItemExpectation

	callArgs []*CartRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteItemExpectation specifies expectation struct of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteItemParams
	paramPtrs          *CartRepositoryMockDeleteItemParamPtrs
	expectationOrigins CartRepositoryMockDeleteItemExpectationOrigins
	results            *CartRepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteItemParams contains parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParams struct {
	ctx context.Context
	u1  model.UserID
	s1  model.Sku
}

// CartRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
	s1  *model.Sku
}

// CartRepositoryMockDeleteItemResults contains results of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemResults struct {
	err error
}

// CartRepositoryMockDeleteItemOrigins contains origins of expectations of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Optional() *mCartRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Expect(ctx context.Context, u1 model.UserID, s1 model.Sku) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartRepositoryMockDeleteItemParams{ctx, u1, s1}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectU1Param2 sets up expected param u1 for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectU1Param2(u1 model.UserID) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteItem.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectS1Param3 sets up expected param s1 for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectS1Param3(s1 model.Sku) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteItem.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, u1 model.UserID, s1 model.Sku)) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Return(err error) *CartRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartRepositoryMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartRepository.DeleteItem method
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Set(f func(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error)) *CartRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the CartRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartRepositoryMockDeleteItem) When(ctx context.Context, u1 model.UserID, s1 model.Sku) *CartRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &CartRepositoryMockDeleteItemParams{ctx, u1, s1},
		expectationOrigins: CartRepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItem should be invoked
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Times(n uint64) *mCartRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mCartRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_cart.CartRepository
func (mmDeleteItem *CartRepositoryMock) DeleteItem(ctx context.Context, u1 model.UserID, s1 model.Sku) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, u1, s1)
	}

	mm_params := CartRepositoryMockDeleteItemParams{ctx, u1, s1}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemParams{ctx, u1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartRepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, u1, s1)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItem. %v %v %v", ctx, u1, s1)
	return
}

// DeleteItemAfterCounter returns a count of finished CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Calls() []*CartRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx context.Context
	u1  model.UserID
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx *context.Context
	u1  *model.UserID
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	ia1 []model.Item
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, u1 model.UserID) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, u1}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectU1Param2 sets up expected param u1 for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectU1Param2(u1 model.UserID) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.u1 = &u1
	mmGetCart.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, u1 model.UserID)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(ia1 []model.Item, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{ia1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, u1 model.UserID) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{ctx, u1},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(ia1 []model.Item, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{ia1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_cart.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, u1 model.UserID) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, u1)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, u1}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, u1)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, u1)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteCartInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetCartDone()
}
