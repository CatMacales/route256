// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/CatMacales/route256/loms/internal/service/loms.OrderProvider -o order_provider_mock.go -n OrderProviderMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/CatMacales/route256/loms/internal/domain/model"
	"github.com/gojuno/minimock/v3"
)

// OrderProviderMock implements mm_loms.OrderProvider
type OrderProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, o1 model.Order) (o2 model.OrderID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, o1 model.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderProviderMockCreate

	funcGetByOrderID          func(ctx context.Context, o1 model.OrderID) (op1 *model.Order, err error)
	funcGetByOrderIDOrigin    string
	inspectFuncGetByOrderID   func(ctx context.Context, o1 model.OrderID)
	afterGetByOrderIDCounter  uint64
	beforeGetByOrderIDCounter uint64
	GetByOrderIDMock          mOrderProviderMockGetByOrderID

	funcSetStatus          func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderProviderMockSetStatus
}

// NewOrderProviderMock returns a mock for mm_loms.OrderProvider
func NewOrderProviderMock(t minimock.Tester) *OrderProviderMock {
	m := &OrderProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderProviderMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderProviderMockCreateParams{}

	m.GetByOrderIDMock = mOrderProviderMockGetByOrderID{mock: m}
	m.GetByOrderIDMock.callArgs = []*OrderProviderMockGetByOrderIDParams{}

	m.SetStatusMock = mOrderProviderMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderProviderMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderProviderMockCreate struct {
	optional           bool
	mock               *OrderProviderMock
	defaultExpectation *OrderProviderMockCreateExpectation
	expectations       []*OrderProviderMockCreateExpectation

	callArgs []*OrderProviderMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderProviderMockCreateExpectation specifies expectation struct of the OrderProvider.Create
type OrderProviderMockCreateExpectation struct {
	mock               *OrderProviderMock
	params             *OrderProviderMockCreateParams
	paramPtrs          *OrderProviderMockCreateParamPtrs
	expectationOrigins OrderProviderMockCreateExpectationOrigins
	results            *OrderProviderMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrderProviderMockCreateParams contains parameters of the OrderProvider.Create
type OrderProviderMockCreateParams struct {
	ctx context.Context
	o1  model.Order
}

// OrderProviderMockCreateParamPtrs contains pointers to parameters of the OrderProvider.Create
type OrderProviderMockCreateParamPtrs struct {
	ctx *context.Context
	o1  *model.Order
}

// OrderProviderMockCreateResults contains results of the OrderProvider.Create
type OrderProviderMockCreateResults struct {
	o2  model.OrderID
	err error
}

// OrderProviderMockCreateOrigins contains origins of expectations of the OrderProvider.Create
type OrderProviderMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderProviderMockCreate) Optional() *mOrderProviderMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrderProvider.Create
func (mmCreate *mOrderProviderMockCreate) Expect(ctx context.Context, o1 model.Order) *mOrderProviderMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderProviderMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderProviderMockCreateParams{ctx, o1}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrderProvider.Create
func (mmCreate *mOrderProviderMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderProviderMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderProviderMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderProviderMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectO1Param2 sets up expected param o1 for OrderProvider.Create
func (mmCreate *mOrderProviderMockCreate) ExpectO1Param2(o1 model.Order) *mOrderProviderMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderProviderMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderProviderMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.o1 = &o1
	mmCreate.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderProvider.Create
func (mmCreate *mOrderProviderMockCreate) Inspect(f func(ctx context.Context, o1 model.Order)) *mOrderProviderMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderProviderMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderProvider.Create
func (mmCreate *mOrderProviderMockCreate) Return(o2 model.OrderID, err error) *OrderProviderMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderProviderMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderProviderMockCreateResults{o2, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OrderProvider.Create method
func (mmCreate *mOrderProviderMockCreate) Set(f func(ctx context.Context, o1 model.Order) (o2 model.OrderID, err error)) *OrderProviderMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderProvider.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderProvider.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OrderProvider.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderProviderMockCreate) When(ctx context.Context, o1 model.Order) *OrderProviderMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderProviderMock.Create mock is already set by Set")
	}

	expectation := &OrderProviderMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrderProviderMockCreateParams{ctx, o1},
		expectationOrigins: OrderProviderMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderProvider.Create return parameters for the expectation previously defined by the When method
func (e *OrderProviderMockCreateExpectation) Then(o2 model.OrderID, err error) *OrderProviderMock {
	e.results = &OrderProviderMockCreateResults{o2, err}
	return e.mock
}

// Times sets number of times OrderProvider.Create should be invoked
func (mmCreate *mOrderProviderMockCreate) Times(n uint64) *mOrderProviderMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderProviderMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrderProviderMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_loms.OrderProvider
func (mmCreate *OrderProviderMock) Create(ctx context.Context, o1 model.Order) (o2 model.OrderID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, o1)
	}

	mm_params := OrderProviderMockCreateParams{ctx, o1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderProviderMockCreateParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderProviderMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmCreate.t.Errorf("OrderProviderMock.Create got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderProviderMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderProviderMock.Create")
		}
		return (*mm_results).o2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, o1)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderProviderMock.Create. %v %v", ctx, o1)
	return
}

// CreateAfterCounter returns a count of finished OrderProviderMock.Create invocations
func (mmCreate *OrderProviderMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderProviderMock.Create invocations
func (mmCreate *OrderProviderMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderProviderMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderProviderMockCreate) Calls() []*OrderProviderMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderProviderMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderProviderMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderProviderMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderProviderMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderProviderMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderProviderMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrderProviderMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderProviderMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrderProviderMockGetByOrderID struct {
	optional           bool
	mock               *OrderProviderMock
	defaultExpectation *OrderProviderMockGetByOrderIDExpectation
	expectations       []*OrderProviderMockGetByOrderIDExpectation

	callArgs []*OrderProviderMockGetByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderProviderMockGetByOrderIDExpectation specifies expectation struct of the OrderProvider.GetByOrderID
type OrderProviderMockGetByOrderIDExpectation struct {
	mock               *OrderProviderMock
	params             *OrderProviderMockGetByOrderIDParams
	paramPtrs          *OrderProviderMockGetByOrderIDParamPtrs
	expectationOrigins OrderProviderMockGetByOrderIDExpectationOrigins
	results            *OrderProviderMockGetByOrderIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderProviderMockGetByOrderIDParams contains parameters of the OrderProvider.GetByOrderID
type OrderProviderMockGetByOrderIDParams struct {
	ctx context.Context
	o1  model.OrderID
}

// OrderProviderMockGetByOrderIDParamPtrs contains pointers to parameters of the OrderProvider.GetByOrderID
type OrderProviderMockGetByOrderIDParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderID
}

// OrderProviderMockGetByOrderIDResults contains results of the OrderProvider.GetByOrderID
type OrderProviderMockGetByOrderIDResults struct {
	op1 *model.Order
	err error
}

// OrderProviderMockGetByOrderIDOrigins contains origins of expectations of the OrderProvider.GetByOrderID
type OrderProviderMockGetByOrderIDExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Optional() *mOrderProviderMockGetByOrderID {
	mmGetByOrderID.optional = true
	return mmGetByOrderID
}

// Expect sets up expected params for OrderProvider.GetByOrderID
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Expect(ctx context.Context, o1 model.OrderID) *mOrderProviderMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderProviderMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by ExpectParams functions")
	}

	mmGetByOrderID.defaultExpectation.params = &OrderProviderMockGetByOrderIDParams{ctx, o1}
	mmGetByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByOrderID.expectations {
		if minimock.Equal(e.params, mmGetByOrderID.defaultExpectation.params) {
			mmGetByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderID.defaultExpectation.params)
		}
	}

	return mmGetByOrderID
}

// ExpectCtxParam1 sets up expected param ctx for OrderProvider.GetByOrderID
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) ExpectCtxParam1(ctx context.Context) *mOrderProviderMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderProviderMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderProviderMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByOrderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByOrderID
}

// ExpectO1Param2 sets up expected param o1 for OrderProvider.GetByOrderID
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) ExpectO1Param2(o1 model.OrderID) *mOrderProviderMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderProviderMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderProviderMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.o1 = &o1
	mmGetByOrderID.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmGetByOrderID
}

// Inspect accepts an inspector function that has same arguments as the OrderProvider.GetByOrderID
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Inspect(f func(ctx context.Context, o1 model.OrderID)) *mOrderProviderMockGetByOrderID {
	if mmGetByOrderID.mock.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("Inspect function is already set for OrderProviderMock.GetByOrderID")
	}

	mmGetByOrderID.mock.inspectFuncGetByOrderID = f

	return mmGetByOrderID
}

// Return sets up results that will be returned by OrderProvider.GetByOrderID
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Return(op1 *model.Order, err error) *OrderProviderMock {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderProviderMockGetByOrderIDExpectation{mock: mmGetByOrderID.mock}
	}
	mmGetByOrderID.defaultExpectation.results = &OrderProviderMockGetByOrderIDResults{op1, err}
	mmGetByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// Set uses given function f to mock the OrderProvider.GetByOrderID method
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Set(f func(ctx context.Context, o1 model.OrderID) (op1 *model.Order, err error)) *OrderProviderMock {
	if mmGetByOrderID.defaultExpectation != nil {
		mmGetByOrderID.mock.t.Fatalf("Default expectation is already set for the OrderProvider.GetByOrderID method")
	}

	if len(mmGetByOrderID.expectations) > 0 {
		mmGetByOrderID.mock.t.Fatalf("Some expectations are already set for the OrderProvider.GetByOrderID method")
	}

	mmGetByOrderID.mock.funcGetByOrderID = f
	mmGetByOrderID.mock.funcGetByOrderIDOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// When sets expectation for the OrderProvider.GetByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) When(ctx context.Context, o1 model.OrderID) *OrderProviderMockGetByOrderIDExpectation {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderProviderMock.GetByOrderID mock is already set by Set")
	}

	expectation := &OrderProviderMockGetByOrderIDExpectation{
		mock:               mmGetByOrderID.mock,
		params:             &OrderProviderMockGetByOrderIDParams{ctx, o1},
		expectationOrigins: OrderProviderMockGetByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByOrderID.expectations = append(mmGetByOrderID.expectations, expectation)
	return expectation
}

// Then sets up OrderProvider.GetByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderProviderMockGetByOrderIDExpectation) Then(op1 *model.Order, err error) *OrderProviderMock {
	e.results = &OrderProviderMockGetByOrderIDResults{op1, err}
	return e.mock
}

// Times sets number of times OrderProvider.GetByOrderID should be invoked
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Times(n uint64) *mOrderProviderMockGetByOrderID {
	if n == 0 {
		mmGetByOrderID.mock.t.Fatalf("Times of OrderProviderMock.GetByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByOrderID.expectedInvocations, n)
	mmGetByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID
}

func (mmGetByOrderID *mOrderProviderMockGetByOrderID) invocationsDone() bool {
	if len(mmGetByOrderID.expectations) == 0 && mmGetByOrderID.defaultExpectation == nil && mmGetByOrderID.mock.funcGetByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.mock.afterGetByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByOrderID implements mm_loms.OrderProvider
func (mmGetByOrderID *OrderProviderMock) GetByOrderID(ctx context.Context, o1 model.OrderID) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetByOrderID.beforeGetByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderID.afterGetByOrderIDCounter, 1)

	mmGetByOrderID.t.Helper()

	if mmGetByOrderID.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.inspectFuncGetByOrderID(ctx, o1)
	}

	mm_params := OrderProviderMockGetByOrderIDParams{ctx, o1}

	// Record call args
	mmGetByOrderID.GetByOrderIDMock.mutex.Lock()
	mmGetByOrderID.GetByOrderIDMock.callArgs = append(mmGetByOrderID.GetByOrderIDMock.callArgs, &mm_params)
	mmGetByOrderID.GetByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetByOrderID.GetByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetByOrderID.GetByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderID.GetByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := OrderProviderMockGetByOrderIDParams{ctx, o1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByOrderID.t.Errorf("OrderProviderMock.GetByOrderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmGetByOrderID.t.Errorf("OrderProviderMock.GetByOrderID got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderID.t.Errorf("OrderProviderMock.GetByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderID.t.Fatal("No results are set for the OrderProviderMock.GetByOrderID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetByOrderID.funcGetByOrderID != nil {
		return mmGetByOrderID.funcGetByOrderID(ctx, o1)
	}
	mmGetByOrderID.t.Fatalf("Unexpected call to OrderProviderMock.GetByOrderID. %v %v", ctx, o1)
	return
}

// GetByOrderIDAfterCounter returns a count of finished OrderProviderMock.GetByOrderID invocations
func (mmGetByOrderID *OrderProviderMock) GetByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.afterGetByOrderIDCounter)
}

// GetByOrderIDBeforeCounter returns a count of OrderProviderMock.GetByOrderID invocations
func (mmGetByOrderID *OrderProviderMock) GetByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.beforeGetByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderProviderMock.GetByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderID *mOrderProviderMockGetByOrderID) Calls() []*OrderProviderMockGetByOrderIDParams {
	mmGetByOrderID.mutex.RLock()

	argCopy := make([]*OrderProviderMockGetByOrderIDParams, len(mmGetByOrderID.callArgs))
	copy(argCopy, mmGetByOrderID.callArgs)

	mmGetByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDDone returns true if the count of the GetByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderProviderMock) MinimockGetByOrderIDDone() bool {
	if m.GetByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByOrderIDMock.invocationsDone()
}

// MinimockGetByOrderIDInspect logs each unmet expectation
func (m *OrderProviderMock) MinimockGetByOrderIDInspect() {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderProviderMock.GetByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && afterGetByOrderIDCounter < 1 {
		if m.GetByOrderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderProviderMock.GetByOrderID at\n%s", m.GetByOrderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderProviderMock.GetByOrderID at\n%s with params: %#v", m.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && afterGetByOrderIDCounter < 1 {
		m.t.Errorf("Expected call to OrderProviderMock.GetByOrderID at\n%s", m.funcGetByOrderIDOrigin)
	}

	if !m.GetByOrderIDMock.invocationsDone() && afterGetByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderProviderMock.GetByOrderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByOrderIDMock.expectedInvocations), m.GetByOrderIDMock.expectedInvocationsOrigin, afterGetByOrderIDCounter)
	}
}

type mOrderProviderMockSetStatus struct {
	optional           bool
	mock               *OrderProviderMock
	defaultExpectation *OrderProviderMockSetStatusExpectation
	expectations       []*OrderProviderMockSetStatusExpectation

	callArgs []*OrderProviderMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderProviderMockSetStatusExpectation specifies expectation struct of the OrderProvider.SetStatus
type OrderProviderMockSetStatusExpectation struct {
	mock               *OrderProviderMock
	params             *OrderProviderMockSetStatusParams
	paramPtrs          *OrderProviderMockSetStatusParamPtrs
	expectationOrigins OrderProviderMockSetStatusExpectationOrigins
	results            *OrderProviderMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrderProviderMockSetStatusParams contains parameters of the OrderProvider.SetStatus
type OrderProviderMockSetStatusParams struct {
	ctx context.Context
	o1  model.OrderID
	o2  model.OrderStatus
}

// OrderProviderMockSetStatusParamPtrs contains pointers to parameters of the OrderProvider.SetStatus
type OrderProviderMockSetStatusParamPtrs struct {
	ctx *context.Context
	o1  *model.OrderID
	o2  *model.OrderStatus
}

// OrderProviderMockSetStatusResults contains results of the OrderProvider.SetStatus
type OrderProviderMockSetStatusResults struct {
	err error
}

// OrderProviderMockSetStatusOrigins contains origins of expectations of the OrderProvider.SetStatus
type OrderProviderMockSetStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originO2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderProviderMockSetStatus) Optional() *mOrderProviderMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) Expect(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) *mOrderProviderMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderProviderMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderProviderMockSetStatusParams{ctx, o1, o2}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderProviderMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderProviderMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderProviderMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectO1Param2 sets up expected param o1 for OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) ExpectO1Param2(o1 model.OrderID) *mOrderProviderMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderProviderMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderProviderMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o1 = &o1
	mmSetStatus.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectO2Param3 sets up expected param o2 for OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) ExpectO2Param3(o2 model.OrderStatus) *mOrderProviderMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderProviderMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderProviderMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.o2 = &o2
	mmSetStatus.defaultExpectation.expectationOrigins.originO2 = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) Inspect(f func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus)) *mOrderProviderMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderProviderMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderProvider.SetStatus
func (mmSetStatus *mOrderProviderMockSetStatus) Return(err error) *OrderProviderMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderProviderMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderProviderMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderProvider.SetStatus method
func (mmSetStatus *mOrderProviderMockSetStatus) Set(f func(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error)) *OrderProviderMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderProvider.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderProvider.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the OrderProvider.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderProviderMockSetStatus) When(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) *OrderProviderMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderProviderMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderProviderMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &OrderProviderMockSetStatusParams{ctx, o1, o2},
		expectationOrigins: OrderProviderMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderProvider.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderProviderMockSetStatusExpectation) Then(err error) *OrderProviderMock {
	e.results = &OrderProviderMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrderProvider.SetStatus should be invoked
func (mmSetStatus *mOrderProviderMockSetStatus) Times(n uint64) *mOrderProviderMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderProviderMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mOrderProviderMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_loms.OrderProvider
func (mmSetStatus *OrderProviderMock) SetStatus(ctx context.Context, o1 model.OrderID, o2 model.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, o1, o2)
	}

	mm_params := OrderProviderMockSetStatusParams{ctx, o1, o2}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderProviderMockSetStatusParams{ctx, o1, o2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderProviderMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetStatus.t.Errorf("OrderProviderMock.SetStatus got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.o2 != nil && !minimock.Equal(*mm_want_ptrs.o2, mm_got.o2) {
				mmSetStatus.t.Errorf("OrderProviderMock.SetStatus got unexpected parameter o2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originO2, *mm_want_ptrs.o2, mm_got.o2, minimock.Diff(*mm_want_ptrs.o2, mm_got.o2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderProviderMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderProviderMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, o1, o2)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderProviderMock.SetStatus. %v %v %v", ctx, o1, o2)
	return
}

// SetStatusAfterCounter returns a count of finished OrderProviderMock.SetStatus invocations
func (mmSetStatus *OrderProviderMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderProviderMock.SetStatus invocations
func (mmSetStatus *OrderProviderMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderProviderMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderProviderMockSetStatus) Calls() []*OrderProviderMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderProviderMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderProviderMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderProviderMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderProviderMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderProviderMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderProviderMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to OrderProviderMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderProviderMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByOrderIDInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByOrderIDDone() &&
		m.MinimockSetStatusDone()
}
